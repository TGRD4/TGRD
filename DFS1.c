/*引入实例：将n张不同的牌放入n个箱子里，一个箱子一张牌，总共几种方法?*/

/*
思路：此处一共分为四步操作：
1.按规定顺序放牌入箱子里（这里规定放牌的顺序从小到大）
2.人的移动(step++)
3.箱子都放满了并且输出这种情况
4.返回收牌（若不满足放牌的条件则一直返回收牌直到：a.全部情况输出完成，结束循环；b.满足放牌条件进行而新的一轮循环（返回第一步）。

以上四步循环操作输出全部结果。
*/

#include<stdio.h>
int n,s[10],book[10];//设置全局变量使数组初始值为0（一开始牌全部在手上）
//book[]用来标记牌的状态：0.在手上未使用过；1.在箱子里已经使用过
void dfs(int step);
int main()
{
    scanf("%d",&n);//输入手牌数（=箱子数）
    dfs(1);//刚开始选择第一个箱子
    return 0;
}
/*DFS是解决当前怎么做*/
void dfs(int step)//调用一次dfs函数就相当于移动了一步（换了一个箱子放牌）
{
    int i;
    if(step>n)//如果箱子全部放满
    {
        for(i=1;i<=n;i++)
            printf("%d ",s[i]);//则输出已排序好的序列
        putchar('\n');
        return;//并且返回上一个箱子拿回牌
    }
    for(i=1;i<=n;i++)//在每一个箱子前都要依次判断手牌情况
    {
        if(book[i]==0)//如过这张手牌在手上
        {
            s[step]=i;//则将这张手牌放入箱子
            book[i]=1;//并且标记这张手牌已经使用过了防止在输出一种情况前二次使用
            dfs(step+1);//放下一张手牌后选择下一个箱子继续放置手牌

            book[i]=0;//拿回已输出的情况的牌并且标记拿回的牌状态为未使用过
            /*若到达这一步，可能有两种情况（相当于一种情况）：
            1.箱子全部放满，收回最后一个箱子里的牌(在第一个return处返回)；
            2.在一个箱子前但是手上的手牌都已经放到过这个箱子(在最后一个return处返回)*/
        }
        //如果不在手上则继续判断i+1张牌在不在手上
    }
    return;
}