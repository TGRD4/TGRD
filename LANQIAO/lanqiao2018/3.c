#include<stdio.h>
#include<string.h>
#include<math.h>
int dp[1001][1001];
int main() {
	int n=1000,m=3;
    /*初始化dp为最坏情况（有多少层就要摔多少次），而且每一层都要摔碎*/
	for(int i=1;i<=n;i++) {
		dp[i][1]=i;
    }
	for(int i=1;i<=m;i++) {
		dp[1][i]=1;
    }

    /*剩余j部手机，i层楼*/
    /*dp，一步步考虑（只注重当前最优解）*/
	for(int i=1;i<=n;i++) {
		for(int j=2;j<=m;j++) {
            dp[i][j]=dp[i][j-1];    //j-1部手机测试出来的楼层j部手机也可以测试出来（去重）
            for(int k=1;k<=i;k++) {

                /*"最佳策略"，"最坏运气"，意思应该是把3部手机都摔坏并且是最后一次才测出来耐摔指数的最小次数*/
                /*相当于在 获得最坏运气的情况下 又要采取最佳策略以 获得期待的结果*/
                dp[i][j]=fmin(dp[i][j],fmax(dp[k-1][j-1],dp[i-k][j])+1);//最优子结构性质

                //+1（加上这次尝试次数），与之前的尝试次数相比取最小值
                /*相当于将 在此楼层不摔和摔之间 做对比，看哪一个比当前情况（若是每层都摔坏根本得不到结果）更好，
                而在决定摔时 取摔的尝试次数最大值 同时又保证了在能得到结果的前提下 获得最坏情况*/
/*
两种情况：
1.在k层摔碎了，那么剩余楼层就是k层楼之前的所有楼层，并且手机数-1
2.在k层未摔碎，剩余楼层就是k层楼之后的所有楼层，手机数不减
以上两种情况取次数最大值，因为要找出的是最坏的情况;
又因为初始化dp为最坏情况（最多的尝试次数），所以之后的尝试次数只能取两者之间最小值
*/			}
        }
    }
    /*dp[i][j]的每一项都保证了在还剩j个手机时，能在把最后一个手机消耗完后刚好获得最差结果*/
	printf("%d",dp[1000][3]);       //输出最差运气（试到最后一层才出结果并且摔坏了三个手机）
	return 0;
}
