#include<stdio.h>
typedef long long ll;
int dp[102][100002];

int main() {
    int n;
    scanf("%d",&n);
    int w[n+1];
    ll sum=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&w[i]);
        sum+=w[i];                      //获取最大组成重量为所有砝码质量之和
    }
    //dp思想（一步步获取最大值，只考虑当前一步，逐渐组成最大值）
    //相当于从所有步骤的前一位开始计算，逐步考虑 
    for(int i=1;i<=n;i++) {             //砝码总数循环 
        for(int j=1;j<=sum;j++) {       //总重量循环 
            dp[i][j]=dp[i-1][j];        //去重（前i-1个砝码可组装出来的重量前i个也可以组装出来）
            if(dp[i][j]==0) {           //如果前i-1个砝码组装不出来重量j
                if(w[i]>j) dp[i][j]=dp[i-1][w[i]-j];    //替换目标重量为 当前砝码重量w[i]-目标重量j
/*
当前单个砝码i重量大于目标重量，则 （判断前i-1个的总重量等不等于当前单个砝码i的重量-目标重量），如果替换后dp[i][j]还是等于0，
则目前组装不出来，若替换后dp[i][j]>0,则说明加上当前砝码重量可以组成前i-1个砝码组成的重量（令目标重量相等）
（开始时没加当前质量，而是把当前可组装重量替换成了前i-1个砝码可以组装的重量）
*/
                if(w[i]==j) dp[i][j]=1;                 //当前单个砝码质量等于目标重量则说明目标j重量可以被单组装出来，令dp=1
                if(w[i]<j) dp[i][j]=dp[i-1][j-w[i]];    //当前砝码质量小于目标重量，说明不一定组不出来目标重量j，
//需要在当前基础上向前一步考虑，替换目标质量为 目标重量j-当前砝码质量w[i]（若加上当前砝码重量等于目标质量则说明可以组成目标重量）
            }
        }
    }

    ll ans=0;
    for(int i=1;i<=sum;i++) {
        if(dp[n][i]) {//若可以组成目标质量则可组成的质量+1
            ans++;
        }
    }
    printf("%lld",ans);
    return 0;
}
