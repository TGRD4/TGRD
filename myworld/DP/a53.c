/*https://leetcode-cn.com/problems/maximum-subarray/*/
A.
/*经典模版：求一个数列的最大连续子序列和*/
/*之后很多题都与此题思路一致*/
/*
用pre保留这一位的数值加上之前保留的子序列最大值的和，与这一位本身进行比较，保留最大值。
若前方子序列总和都没有这一位大，那么就从这一位开始计数；若本位与前方总序列总和更大则加上本位
max将保留的已计算过的所有子序列中最大和与pre进行比较，保留最大值
*/
int maxSubArray(int* nums, int numsSize) 
{
    int pre = 0, max = nums[0];
    for (int i = 0; i < numsSize; i++) {
        pre = fmax(pre + nums[i], nums[i]);//将当前位与前保留的最大子序列和的和与当前位进行对比，保留最大值
        max = fmax(max, pre);//保留前所有子序列中最大的值
    }
    return max;//返回最大值
}

/*
上式相当于：
pre = fmax(加上此位，只取此位)  ==>都是取了此位的
max = fmax(不加此位，fmax(加上此位，只取此位))  ==>可以不加上此位
相当于对每一位都考虑了三种情况后求出最大值

这里设置 加上此位是a种情况，只取此位是b,不加此位是c，fmax(加上此位，只取此位)是d:
pre中存在(a,b)种情况
max中存在(c,d)种情况

举例：
给出一段数列nums[]={-2，1，-3，4，-1，2，1，-5，4}
先设定所有连续子序列最大值max=nums[0]=-2,设置刚开始i=-1,pre初始值就是nums[-1]，这里设置为0

进入循环：
i=0 (nums[0]=-2):
    pre=fmax(0+nums[0],nums[0])=fmax(-2,-2)=-2;此时pre保留了当前位和前方最大连续子序列和为-2  (-2前最大连续子序列就是num[-1]=pre=0)
    max=fmax(nums[0],pre)=fmax(-2,-2)=-2；此时max保留所有遍历过的子序列中和最大的值为-2
i=1 (nums[1]=1):
    pre=fmax(-2+1,1)=fmax(-1,1)=1;此时属于情况b，只取了此位，因为这一位就比前面的总和都要大
    max=fmax(-2,1)=1;此时在max中属于情况d，取了加上此位和只取此位中的最大值，也就是pre(pre=fmax(加上此位，只取此位));
i=2 (nums[2]=-3)：
    pre=fmax(1+-3,-3)=(-2,-3)=-2;情况a,虽然是负数，但因为前子数列最大和是正数，而此位是负数，加上此位比只取此位要大
    max=fmax(1,-2)=1;情况c，没有加上此位，因为加上此位比之前保留的最大总和要小
i=3 (nums[3]=4)
    pre=fmax(-2+4，4)=4；情况b，只取了此位
    max=fmax(1,4);情况d，取了此位中并且只取此位的情况（相当于从i=3作为最大连续子序列的头再向后开始寻找）
....

到最后max保留的是从-4到1的和6，因为后续-5+4明显是负数若取上最大和变小，相当于1后面max取的都是情况c，不加此位
而pre到最后一位都一直在更新，因为它一直都是加上每一位后再进行的最大取值，少了一种不加此位的比较，
而max刚好可以进行不加此位的判断，所以pre相当于在为max提供一个参数以便于考虑到所有情况，以防对最大值的误判
最后返回的max就是在对每一位都考虑过三种情况后产生的最大值
*/
 