/*跳跃成功与否*/
D.
/*
https://leetcode-cn.com/problems/jump-game/
*/
/*
给定一个非负整数数组 nums ，你最初位于数组的第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
*/
/*还是dp思想，只注重于当前一步应该怎么走，保留这一步产生的结果用于下一次的计算，
每一步都保留住最好的结果最后一步自然会返回最好的结果。

在这一题中的体现就是不停用k保留前方所有跳跃结果的最大值，直到最后一位判断是否保留的最大值大过了或者刚好等于终点值以此来判断是否能到达终点*/

bool canJump(int* nums, int numsSize){
    int i = 0;
    for (int k = 0; i < numsSize && i <= k; i++) 
        k = fmax(k, i + nums[i]);
/*将这一点的位置（下标i）与从这一点能跳出的最大长度（距离nums[i]）相加，
得到从这一点跳到下一点的最大位置，与从前一点能跳到的最大位置相比，保留最大值。

一旦出现一点的前方能跳到的最远位置(前面保留的k)小于这一点的位置，
说明无论如何前面的点都跳不到当前这一点，那么后面的位置也更到不了，返回false
如果循环结束了(i>=numsSize),也没有找到到不了的点，那就返回true*/
    return i >= numsSize;
}

