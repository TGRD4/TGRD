/*Dijkstra算法，寻找单源最短路径（一个顶点到其余所有顶点的最短路径）
这里寻找一号顶点到其余所有顶点的最短路径*/
#include<stdio.h>
#define MAX 0x3f3f3f3f//无穷
#define N 101
int main()
{
    int  e[N][N]={0},n,m,a,b,c,min,t;
    int book[N]={0},dis[N];//用dis数组来储存1号顶点原始到所有顶点的最短路径
    scanf("%d %d",&n,&m);
    /*初始化图*/
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j) e[i][j]=MAX;
    /*初始化网*/
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %d",&a,&b,&c);//图加带权(c)边=网
        e[a][b]=c;//有向网
    }
    /*初始化dis数组*/
    for(int i=1;i<=n;i++)
        dis[i]=e[1][i];//初始最短路径就是1号直接到顶点的路径，无中转点
    book[1]=1;//标记1号已经全部出边了（初始化）


    for(int i=1;i<=n-1;i++)//循环n-1次找到所有顶点距离1号的最短路径
    {
        min=MAX;//每次将min重置为无穷（否则一个顶点会被重复计算出边）
        for(int j=1;j<=n;j++)//找距离1号最近距离的
        {
            if(book[j]==0&&dis[j]<min)//并且没有被松弛过的顶点
            {
                min=dis[j];//保留路径进行下一次比较以找到最短路径
                t=j;//保留该顶点的下标
            }
        }
        for(int j=1;j<=n;j++)
        {
            if(e[t][j]<MAX)
            {
                if(dis[j]>dis[t]+e[t][j])//对此顶点进行松弛以找到距离1号最短的距离
                    dis[j]=dis[t]+e[t][j];
            }
        }
        book[t]=1;//标记该顶点松弛过了，防止重复松弛以结果的不准确
    }
    for(int i=1;i<=n;i++)
        printf("%d ",dis[i]);//输出所有顶点距离1号顶点的最短路径
    getchar();getchar();
    return 0;
}
/*
6 9
1 2 1
1 3 12
2 3 9
2 4 3
3 5 5
4 3 4
4 5 13
4 6 15
5 6 4
*/

/*  松弛：比如从1号到3号顶点的直接距离是16，而从1号顶点到2号顶点的距离是4，从2号顶点到3号顶点的距离是8，
那么就可以从1号顶点先到2号顶点再到3号顶点，距离12<16，这样通过2号顶点（中转点）缩短1号顶点到3号顶点的距离的操作就叫做松弛，
可以说1->3的距离dis[3]，通过2->3松弛成功，这样对于1号顶点的每条边进行松弛，就可以找到所有顶点到1号顶点的最短距离  */
