/*Prim算法与Dijkstra类似，不同在于：
Dijkstra用于计算一个点的单源最短路，dis记录的是每一个顶点到1号顶点的最短路径；
而Prim是将每个顶点都作为目标点去寻找到任意一个已生成树顶点的最短路经，dis记录的是生成树到各个点的距离，
因此在更新最短路径时不用加dis，因为最终目标不是到1号顶点的最短路径，而是到生成树中的任意一个顶点的最短路径*/

/*核心思想是先选择任意一个顶点加入生成树，
枚举这一点的所有出边并找到与最小出边连接的顶点也加入生成树，
再在生成树中所有顶点的出边中找到未被连接的且出边最小的顶点加入生成树，
一直重复上述过程直到找到所有顶点加入生成树*/

#include<stdio.h>
int main()
{
    int n,m,i,j,k,min,t1,t2,t3;
    int e[10][10]={0},book[10]={0},dis[10];
    int inf=0x3f3f3f3f;
    int cnt=0,sum=0;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(i!=j) e[i][j]=inf;//初始化图
    for(i=1;i<=m;i++)//m为边数
    {
        scanf("%d %d %d",&t1,&t2,&t3);
        e[t1][t2]=t3;
        e[t2][t1]=t3;//无向网
    }

    /*初始化dis数组*/
    for(i=1;i<=n;i++)//n为顶点数
        dis[i]=e[1][i];//此时生成树上只有1号顶点,所以初始化最短距离为所有点与1号顶点的距离
    book[1]=1;//将1号加到生成树
    cnt++;//顶点数加1

    /*Prim核心*/
    while(cnt<n)//最终所有顶点都要进入生成树
    {
        min=inf;
        for(i=1;i<=n;i++)//枚举所有顶点
        {
            if(book[i]==0&&dis[i]<min)
            {
                min=dis[i];//保留最短路径
                j=i;//保留生成树新结点序号
            }
        }
        book[j]=1;//上树
        cnt++;
        sum+=dis[j];//加入总路径
        for(k=1;k<=n;k++)
        {
            if(book[k]==0&&dis[k]>e[j][k])//松弛
                dis[k]=e[j][k];//不用加上原距离而是用新距离替换,因为生成树上多了新的顶点
                //dis记录的是生成树(任意一点)到各点的距离
        }
    }
    printf("sum = %d\n",sum);
    return 0;
}
/*
6 9
2 4 11
3 5 13
4 6 3
5 6 4
2 3 6
4 5 7
1 2 1
3 4 9
1 3 2
*/
