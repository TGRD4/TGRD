/*找出前往迷宫中目标地点的最短路径(0为空地，1为障碍物)*/
/*
1.输入一张迷宫图,用1代表障碍物，0代表空地，设定起始和结束坐标；
2.规定走迷宫的方向：从右开始顺时针选定行走方向，一直走直到遇到墙或者障碍物转向
3.找到目标后记录总路径并和当前最短路径进行比较，保留最短路径
4.多次循环直到遍历完整个迷宫，输出最短路径
*/

#include<stdio.h>
int n,m;
int s[51][51],book[51][51];//设定迷宫大小在50*50以内
int sx,sy,tx,ty,ex,ey,min=0x3f3f3f3f,step;//设置min为无穷大
void dfs(int x,int y);
/*void dfs(int x,int y,int step);
也可以将路径和作为参数传入函数，每调用一次函数路径加1*/
int main()
{
    int i,j;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&s[i][j]);//输入迷宫图
    scanf("%d %d %d %d",&sx,&sy,&ex,&ey);//输入起始和目标坐标
    book[sx][sy]=1;//标记当前起始位置已经走过
    dfs(sx,sy);//参数换为了当前位置的横纵坐标
    printf("min = %d\n",min);//输出最短路径
    return 0;
}
void dfs(int x,int y)//传入当前坐标
{
    int k;
    int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//设定next数组，确定当前位置下一步的走法
    //分别为{1,0}向右走一步，{0,1}向下走一步，{-1,0}向左走一步，{0,-1}向上走一步（顺时针）
    if(x==ex&&y==ey)//当 当前位置就是目标位置时比较路径总和
    {
        if(step<min)
            min=step;//保留最短路径
        return;//返回一步找有没有其它路径
    }
    for(k=0;k<4;k++)//遍历四种方向的走法
    {
        tx=x+next[k][0];//(tx,ty)为 可能的下一步坐标
        ty=y+next[k][1];
        if(tx<1||ty<1||tx>n||ty>m)//这个可能的坐标不能在迷宫外
            continue;//换一个方向再作为 可能的下一步坐标 看能不能走

        if(book[tx][ty]==0&&s[tx][ty]==0)//若在迷宫内且没走过且是空地
        {
            step++;//走一步，总路径加1
            book[tx][ty]=1;//标记当前坐标为走过
            dfs(tx,ty);//传入新的当前坐标（若路径step作为参数则此处是dfs(tx,ty,step+1))
            book[tx][ty]=0;//两种情况：1.走到目标位置；2.走到死路退回
        }
    }
    return;
}

/*
5 4
0 0 1 0
0 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
1 1 4 3
*/
