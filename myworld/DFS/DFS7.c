/*城市地图：导航是如何计算出一个城市到另一个城市的最短路径的？
此处给出若干行从一个城市到另一个城市的路径，求给定两个城市之间的最短路径*/

/*
比如说给出如下数据（都是单向路径）：
5 8//五个城市，八条路径
1 2 2//起始城市，目标城市，之间的路径
1 5 10
2 3 3
2 5 7
3 1 4
3 4 4
4 5 5
5 3 3
使用邻接矩阵表示（最左边纵列表示起始城市a，最上面横列表示目标城市b，矩阵中的数据代表对应两个城市之间的路径）：
自己到自己的城市路径为0，未列出的都是不通的路径设长度设为无穷;
从图中可以看出，两个城市之间的最短路径不一定是连接这两个城市的路，
可以先从起始城市到中间城市再转到目标城市以实现最短路径的寻找，
此类问题也可以使用dfs算法，通过遍历所有起始城市到目标城市的所有路径以找出最短路径
代码如下(dfs)：
*/

#include<stdio.h>
int min=0x3f3f3f3f,book[101],n,e[101][101];//0x3f3f3f3f表示无穷大，e表示城市之间的邻接矩阵
void dfs(int cur,int sum)//cur表示当前城市，sum表示当前总路径
{
    if(sum>min)//如果当前路径已经大于最短路径则不用计算直接返回
        return;
    if(cur==n)//达到目标城市
    {
        if(sum<min)
            min=sum;//记录最短路径
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(e[cur][i]!=0x3f3f3f3f&&book[i]==0)//若两个城市间连通且曾经没有通过此城市
        {
            book[i]=1;//标记城市为走过
            dfs(i,sum+e[cur][i]);//寻找可以到达目标城市的中间城市路径
            book[i]=0;//返回再遍历另一条可以到达目标城市的路径
        }
    }
    return;
}

int main()
{
    int m,a,b,c;
    scanf("%d %d",&n,&m);//此处假设从一号城市出发，到达n号目标城市
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j) e[i][j]=0x3f3f3f3f;//将城市之间的路径都初始化为无穷
            /*此处可省略if(i==j) e[i][j]=0;(自己到自己的城市路径为0)*/
    for(int i=1;i<=m;i++)//创建城市之间的邻接矩阵
    {
        scanf("%d %d %d",&a,&b,&c);
        e[a][b]=c;//因为是有向图，若是无向图则还需加上e[b][a]=c表示从城市b到城市a也可以连通
    }
    book[1]=1;//标记1号城市走过
    dfs(1,0);//当前城市为1,总路径为0
    printf("%d\n",min);//输出两个城市之间的最短路径
    return 0;
}
/*
5 8
1 2 2
1 5 10
2 3 3
2 5 7
3 1 4
3 4 4
4 5 5
5 3 3
*/
